<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Transit Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">
  <link href="css/bootstrap-simplex.css" rel="stylesheet">
  <link href="css/bootstrap-responsive.css" rel="stylesheet">
  <link href="css/docs.css" rel="stylesheet">
</head>
<body data-spy="scroll" data-target=".subnav" data-offset="50">
<div class="container">

  <!-- Masthead
  ================================================== -->
  <header class="jumbotron subhead" id="code">
    <h1>Transit Planner</h1>
    <p class="lead">An experiment on transfer patterns robustness in the presence of real-time updates</p>
    <div class="subnav">
      <ul class="nav nav-pills">
        <li><a href="index.html">Overview</a></li>
        <li><a href="concepts.html">Concepts</a></li>
        <li><a href="implementation.html">Implementation</a></li>
        <li><a href="results.html">Results</a></li>
        <li><a href="conclusion.html">Conclusion</a></li>
        <li class="active"><a href="code.html">Code</a></li>
      </ul>
    </div>
  </header>

  <section id="code">
    <div class="page-header">
      <h1>Code and Datasets</h1>
    </div>
    <p>To provide total transparency of our analysis, we release the code of
    the Transit Planner and the auxiliary modules under the <em>GNU General Public License Version 3</em>. We also provide the datasets used for the experiments. Together with the code, this allows for a complete reproducibility of the experiments.</p>

    <div class="row"><br>
      <div class="span6"><br>
        <h2>Get the Code</h2>
        <p>Download the <a href="TODO">source tarball</a> of the code version
        used during the experiments or check out the latest revision from the
        <a href="TODO">subversion repository</a>.</p>
        <p></p><br>

        <h2>Compile &amp; Test</h2>
        <p>To build Transit Planner use <code>make compile</code>. For
        performance measuring, prefer the more optimized version built
        by <code>make opt</code>.</p>
        <p>To run the unit tests use <code>make test</code>.</p>
        <p>To check code style conformance with the <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++ Code Style</a> use
        <code>make checkstyle</code>.
        <p>Alternatively you can build, test and check style at once using
        <code>make</code>.</p>
        <p></p><br>

        <h2>Usage</h2>
        <p>To start the Transit Planner server use<br>  
        <code>./build/ServerMain [-i &lt;datasets&gt;] [-m &lt;num-workers&gt;] [-p &lt;port&gt;]
        </code>, where <code>&lt;dataset&gt;</code> are the GTFS directories of the
        transit networks,
        <code>&lt;num-workers&gt;</code> are the maximum number of threads to be
        used and
        <code>&lt;port&gt;</code> is the port to be used for listening. To load multiple GTFS feeds, use a space separated list, i.e. <code>-i "GTFS1 GTFS2"</code>.
        </p>
        <p>To show the full usage help use <code>./build/ServerMain -h</code>.</p>
      </div>
      <div class="span6"><br>
        <h2>Web Interface</h2>
        <p>Once the server is running, you can use a regular <em>browser</em> to access the user interface of Transit Planner.</p>
        <p>The user interface consists of the <strong>map area</strong>, the
        <strong>info field</strong> and the <strong>command input</strong>.</p>
        <h3>Map Area</h3>
        <p>The map area is used to view the routes and to conduct manual tests
        on the loaded network.</p>
        <p>By left-clicking on the map you select the departure and destination
        stops. Once at least one destination stop is selected, the optimal routes
        are calculated and displayed on the map. The multi-criteria costs are
        displayed as tuples <em>travel-time, penalty</em>, where travel-time is
        the required time to travel in minutes and penalty is the number of
        transfers and/or walking transitions required on the given route.<br>
        Right-clicking on a selected stop will delete the stop and all its routes.
        </p>
        <p>The displayed routes consist of the travel paths with each transfer
        and walking transitions depicted by a label. When the use of transfer
        patterns is enabled, paths calculated using the transfer patterns are
        displayed in <em>blue</em> and the Dijkstra paths in <em>green</em>.</p>
        <h3>Info Field</h3>
        <p>The info field is right below the map area and displays information
        received from the server. E.g. when conducting experiments an overview
        of the results is be displayed here.</p>
        <h3>Command Input</h3>
        <p>The command input is below the info field and is used to control the server, set client variables, create delay scenarios, conduct experiments, load maps, reproduce specific routes and search for map locations by name.</p>
        <p>All commands start with a <code>/</code>, otherwise a location search
        is triggered. For a full description of all commands use the help command
        <code>/help</code>. To get more specific help about the calling conventions
        of a given command use <code>/help &lt;command&gt;</code>.</p>
      </div>
    </div>
    <div class="row">
      <div class="span6"><br>
        <h2>GTFS Datasets</h2>
        <p>Download the <a href="TODO">New York City dataset</a> and the
        <a href="TODO">Toronto dataset</a> to reproduce the experiments.</p>
      </div>
      <div class="span6"><br>
        <h2>Documentation</h2>
        <p>Here is the <a href="doxygen/index.html">code overview</a> generated by Doxygen.</p>
      </div><br>
    </div>
    <div class="row">
      <div class="span6">
        <h2>Inherent issues</h2>
        <p>During the implementation we made many decisions about the design of our software. Most of them were motivated by our focus on the experiments or to fullfill hardware and time constraints and most proved to be justified. However, after working on the project for many months we now know that some aspects about transit networks and routing with transfer patterns should be handled differently. We state some of our knowledge here along with a description of known but unsolvable (not within a reasonable amount of time) issues in order to make future programers and researchers aware of these problems.
        </p>
        <p>The first issue is around the walking problem. Walking is natural for a person travelling in the real world. But from a programmers point of view, transit network routing with walking is much harder to implement in a reliable and consistent way. We decided to keep the walking graph separately from the transit network. This leads to a problem whenever multiple routes arrive at a destination stop by walking such that they enter at the same transfer/departure node: One of the paths will be lost. The unit-test <code>TransferPatternRouterTest.walkTestCase4</code> gives a detailled example.</p>
        <p>Nowadays we would not pursue the strategy of a separate walking graph any more. Rather than expanding walking arcs on the fly, we recommend to do this when constructing the transit network: For every arrival node expand walking arcs to neighboring stops and add a transit node with the correct time offset, connected by an regular arc. This way walking becomes the same thing as a transfer, which coincides with the intuitive notion: If you transfer between two vehicles, you walk from one to the other. To adapt the transfer pattern precomputation, the backtracking for a start-destination pair should comprise the arrival nodes of the destination and all stops in walking distance rather than the arrival, departure and transfer nodes of the destination stop.</p>
        <p>To regard walking as regular transfer would solve another issue. By forbidding successive walking we encounter the problem that the graph spanned by the transfer patterns is not static. Depending on whether we walked in the last step the next stop has or has not outgoing walking arcs. The test <code>QuerySearchTest.walkOrder</code> gives an example. We overcome this by a forward check in the shortest path search. This solves the problem, but in turn doubles the number of direct connected queries and thereby increases the response time to transfer pattern queries.</p>
        <p>A further problem of our implementation resides in the experiments. We restrict the transfer pattern to hubs to 3 transfers. Longer connections have to go over a hub. (Actually there are routes with more than 3 transfers without hub, see implementation details for the query graph. However, we ignore such queries.) We have to ensure the reference Dijkstra may find longer paths by transferring at a hub station. This is done by maintaining a maximal penalty for each label, which is increased once when transferring at a hub. However, such Dijkstra-paths can be blocked by other paths which leads to failing or suboptimal Dijkstra queries. See test <code>TransferPatternRouterTest.structuralProblem</code> for a detailled explanation.</p>
        <p>Finally, our direct connection data structure does not allow for multiple occurrences of the same stop on a line. There is a unit-test for such a network: <code>DirectConnectionTest.LineFactory_doubleStop</code>. As far as we know, there are no such cyclic connections in the networks of Toronto or New York City. But they exist, for example, in the <a href="http://mobil.wsky.de/Berlin%20S+U-Bahn.jpg">Berlin transit network</a>. A workaround would be a direct connection data structure with incident lists with a set of positions instead of a single position entry. However, we did not pursue this.</p>
      </div>
    </div>
  </section>
  <br><br><br><br>

 <!-- Footer
  ================================================== -->
  <footer class="footer">
    <p>&copy; 2011-2012: Eugen Sawin, Philip Stahl, Jonas Sternisko</p>
    <p class="pull-right"><a href="#">Back to top</a></p>
  </footer>

</div><!-- /container -->

<!-- Placed at the end of the document so the pages load faster -->
<script src="js/jquery.js"></script>
<script src="js/bootstrap-dropdown.js"></script>
<script src="js/bootstrap-scrollspy.js"></script>
<script src="js/bootstrap-collapse.js"></script>
<script src="js/bootstrap-tooltip.js"></script>
<script src="js/application.js"></script>
<script src="js/bootswatch.js"></script>
</body>
</html>
